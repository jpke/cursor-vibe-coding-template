- **Required Rule Structure:**
  ```markdown
  ---
  description: Clear, one-line description of what the rule enforces
  globs: path/to/files/*.ext, other/path/**/*
  alwaysApply: boolean
  ---

  - **Main Points in Bold**
    - Sub-points with details
    - Examples and explanations
  ```

- **File References:**
  - Use `[filename](mdc:path/to/file)` ([filename](mdc:filename)) to reference files
  - Example: [prisma.mdc](mdc:.cursor/rules/prisma.mdc) for rule references
  - Example: [schema.prisma](mdc:prisma/schema.prisma) for code references

- **Code Examples:**
  - Use language-specific code blocks
  ```typescript
  // ✅ DO: Show good examples
  const goodExample = true;
  
  // ❌ DON'T: Show anti-patterns
  const badExample = false;
  ```

- **Rule Content Guidelines:**
  - Start with high-level overview
  - Include specific, actionable requirements
  - Show examples of correct implementation
  - Reference existing code when possible
  - Keep rules DRY by referencing other rules

- **Rule Maintenance:**
  - Update rules when new patterns emerge
  - Add examples from actual codebase
  - Remove outdated patterns
  - Cross-reference related rules

- **Best Practices:**
  - Use bullet points for clarity
  - Keep descriptions concise
  - Include both DO and DON'T examples
  - Reference actual code over theoretical examples
  - Use consistent formatting across rules 

- **Rule Quality Checks:**
  - Rules should be actionable and specific
  - Examples should come from actual code
  - References should be up to date
  - Patterns should be consistently enforced

- **Continuous Improvement:**
  - Monitor code review comments
  - Track common development questions
  - Update rules after major refactors
  - Add links to relevant documentation
  - Cross-reference related rules

- **Rule Deprecation:**
  - Mark outdated patterns as deprecated
  - Remove rules that no longer apply
  - Update references to deprecated rules
  - Document migration paths for old patterns

- **Documentation Updates:**
  - Keep examples synchronized with code
  - Update references to external docs
  - Maintain links between related rules
  - Document breaking changes

- **Memory MCP Workflow**:
  - **User Confirmation Required**: Before creating, updating, or deleting any entities or relationships in the Memory MCP's knowledge graph, I must first explain what I intend to do and ask for your explicit confirmation.

- **MVP Development Workflow**:
  - **Start with HTML**: Every application MVP, regardless of its final platform (e.g., mobile app), should begin as a basic HTML page. This enables rapid prototyping and iteration.
  - **Styling Guidelines**: If you provide a `design.json` file, I will use it as the primary guideline for all styling and visual design choices.

- **Python Virtual Environments**:
  - Always use a virtual environment (`venv`) when running Python scripts. Check for an existing `venv` in the current or parent directories before creating a new one. Activate the `venv` before installing packages or executing scripts.

- **Testing Strategy**:
  - Adopt a Test-Driven Development (TDD) approach where possible. At a minimum, ensure that unit tests are created or updated for any new or modified code.
  - All tests must be passing before a coding task is considered complete.
  - All test reports, artifacts, and error logs must be output to a common `tests_output/` directory at the project root.

- **Taskmaster Workflow**:
  - **PRD as GitHub Issue**:
    1. After generating a Product Requirements Document (PRD), I will work with you to validate its contents.
    2. Once you accept the PRD, I will create a GitHub Issue in the project's repository containing the full text of the PRD.
    3. This GitHub Issue will serve as the single source of truth for the project's requirements. The local PRD file should be considered a temporary draft.
  - **Task Generation Trigger**: I will only generate tasks from the PRD Issue after you explicitly tell me to "start working on the PRD" or give a similar instruction.
  - **Task Confirmation**: After Taskmaster generates tasks, I must confirm with you which task to begin work on *before* executing any of them.

- **Git Initialization Workflow**:
  - When you request to "initialize git repo", I will perform the following steps:
    1.  Initialize a local Git repository (`git init`).
    2.  Create a `.gitignore` file with at least the following entries:
        ```
        # Taskmaster & AI
        specstory/
        .cursor/mcp.json
        .taskmaster/tasks/

        # Dependencies
        node_modules/
        venv/
        ```
    3.  Use the GitHub MCP tool or CLI to create a new **private** remote repository on GitHub, ensuring the 'Issues' feature is enabled.
    4.  Add the new remote to the local repository, stage all initial files, and push the first commit to the `main` branch.
